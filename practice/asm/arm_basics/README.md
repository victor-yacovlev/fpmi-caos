# Основы ассемблера ARM

## Написание и компиляция программ

Программы на языка ассемблера для компилятора GNU сохраняются в файле, имя которого оканчивается на `.s` или `.S`. Во втором случае (с заглавной буквой) подразумевается, что текст программы может быть обработан препроцессором.

Для компиляции используется одна из команд:
`arm-linux-gnueabi-as` или `arm-linux-gnueabi-gcc`. В первом случае текст только компилируется в объектный файл, во втором - в выполняемую программу, скомпонованную со стандартной библиотекой Си, из которой можно использовать функции ввода-вывода.

Процессоры ARM поддерживают два набора команд: основной 32-битный `arm`, и уплотнённый 16-битный `thumb`, между которыми процессор умеет переключаться. В рамках данного семинара мы будем использовать 32-битный набор инструкций, поэтму тексты нужно компилировать с опцией `-marm`.

## Общий синтакис

```
// Это комментарий, как в C++

    .text      // начало секции .text с кодом программы
    .global f  // указание о том, что метка f
               // является доступной извне (аналог extern)

f:             // метка (заканчивается двоеточием)

     // последовательность команд
     mul   r0, r0, r3
     mul   r0, r0, r3
     mul   r1, r1, r3
     add   r0, r0, r1
     add   r0, r0, r2  
     mov   r1, r0
     bx    lr
```

## Регистры

Процессор может выполнять операции только над *регистрами* - 32-биьными ячейками памяти в ядре процессора. У ARM есть
16 регистров, доступных программно: `r0`, `r1`, ... ,`r15`.

У регистров `r13`...`r15` имеются специальные назначения и дополнительные имена:

 * `r15` = `pc`: Program Counter - указатель на текущую выполняемую инструкцию
 * `r14` = `lr`: Link Register - хранит адрес возврата из функции
 * `r13` = `sp`: Stack Pointer - указатель на вершину стека.

## Флаги

Выполнение команд может приводить к появлению некоторой дополнительной информации, которая хранится в *регистре флагов*. Флаги относятся к последней выполненной команде. Основные флаги, это:

 * `C`: Carry - возникло беззнаковое переполнение
 * `V`: oVerflow - возникло знаковое переполнение
 * `N`: Negative - отрицательный результат
 * `Z`: Zero - обнуление результата.

## Команды

Полный перечень 32-битных команд см. в [этом reference](arm_reference.pdf), начиная со 151 страницы.

Архитектура ARM-32 подразумевает, что почти команды могут иметь *условное выполнение*. Условие кодируется 4-мя битами в самой команде, а с точки зрения синтаксиса ассемблера у команд могут быть суффиксы.

Таким образом, каждая команда состоит из двух частей (без разделения пробелами): сама команда и её суффикс.

## Базовые арифметические операции

* `AND regd, rega, argb`  // regd ← rega & argb
* `EOR regd, rega, argb`  // regd ← rega ^ argb
* `SUB regd, rega, argb`  // regd ← rega − argb
* `RSB regd, rega, argb`  // regd ← argb - rega
* `ADD regd, rega, argb`  // regd ← rega + argb
* `ADC regd, rega, argb`  // regd ← rega + argb + carry
* `SBC regd, rega, argb`  // regd ← rega − argb − !carry
* `RSC regd, rega, argb`  // regd ← argb − rega − !carry
* `TST rega, argb`        // set flags for rega & argb
* `TEQ rega, argb`        // set flags for rega ^ argb
* `CMP rega, argb`        // set flags for rega − argb
* `CMN rega, argb`        // set flags for rega + argb
* `ORR regd, rega, argb`  // regd ← rega | argb
* `MOV regd, arg`         // regd ← arg
* `BIC regd, rega, argb`  // regd ← rega & ~argb
* `MVN regd, arg`         // regd ← ~argb

## Суффиксы-условия

```
EQ        equal  (Z)
NE        not equal  (!Z)
CS or HS  carry set / unsigned higher or same  (C)
CC or LO  carry clear / unsigned lower  (!C)
MI        minus / negative  (N)
PL        plus / positive or zero  (!N)
VS        overflow set  (V)
VC        overflow clear  (!V)
HI        unsigned higher  (C && !Z)
LS        unsigned lower or same  (!C || Z)
GE        signed greater than or equal  (N == V)
LT        signed less than  (N != V)
GT        signed greater than  (!Z && (N == V))
LE        signed less than or equal  (Z || (N != V))
```

## Переходы

Счетчик `pc` автоматически увеличивается на 4 при выполнении
очередной инструкции. Для ветвления программ изпользуются команды:

 * `B label` - переход на метку; используется внутри функций для ветвлений, связанных с циклами или условиями
 * `BL label` - сохранение текущего `pc` в `lr` и переход на `label`; обычно используется для вызова функций
 * `BX register` - переход к адресу, указанному в регистре; обычно используется для выхода из функций.

## Работа с памятью

Процессор может выполнять операции только над регистрами. Для взаимодействия с памятью используются отдельные инструкции загрузки/сохранения регистров.

* `LDR regd, [regaddr]` - загружает машинное слово из памяти по адресу, хранящимся в regaddr, и сохраняет его в регистре regd
* `STR reds, [regaddr]` - сохраняет в памяти машинное слово из регистра regs по адресу, указанному в регистре regaddr.
